# 第二章 - 04： 前端 Javascript 实现模块简易管理

模块管理这个概念其实在前几年前端度过了刀耕火种年代之后就一直被提起，那么我们有思考过这个模块管理具体指的是什么东西？什么样子的展现形式？历史由来？现在是什么样的一个状态？

直接回想起来的就是 cmd amd commonJS 这三大模块管理的印象。但是大家清楚 cmd amd commonJS 为什么会出现么？接下来，我们就一起来瞅瞅这具体是啥情况。

> 感觉自己在每一个阶段，对于同一个技术的理解都不一样。

## 一、什么是模块化开发

> 为了让一整个庞大的项目看起来整整齐齐，规规整整而出现的模块化管理，我们常见的三种模块化管理的库： requireJS、seaJS、commonJS 规范 ( 注意，这里的 commonJS 不是一个库，而是一种规范) 逐渐的在我们日常的开发中出现。 同时依赖于 这三类规范而出现的一些构建工具，但最后都败给了 webpack 。这是一篇介绍 webpack 基本入门的文章，可以结合着这篇文章来进行解读。
> [ 《前端之路》之 webpack 4.0+ 的应用构建 ](https://www.cnblogs.com/erbingbing/p/9644898.html)

### 1-1、模块化第一阶段

> 在这个阶段中，我们常常会把非常多复杂的功能 封装成一个个的函数：

```javascript
function f1() {
	// todo
}

function f2() {
	// todo
}
.
.
.
```

> 但是当 整个项目变大了以后，就会遇到很多问题，都是定义的全局变量，形成了比较严重的污染，还有可能会出现因为重命名导致的各种问题。所以这些是需要进化的。所以就会进入到模块化的第二阶段： 对象。

### 1-2、封装到对象

> 到了第二个阶段为了避免全局变量的污染，我们会将单个模块封装到一个对象内部。如下：

```javascript
const module = {
	let _number = 10,
	f1: () => {
		console.log(123)
	},
	f2: () => {
		console.log(456)
	},
	.
	.
	.
}
```

> 这样我们就没个模块定义一个对象，在需要的时候直接调用就好了，但是这样也会存在一个问题
> 这样写的话会暴露全部的对象内部的属性，`内部状态可以被外部改变`. 例如：

```javascript
module._number = 100;
```

> 如果我们支付相关模块这样子来写的话。我们随意的来改变支付的金额，那样就会出现比较危险的情况。

### 1-3、 对象的优化

> 后来，聪明的人类就想到了利用 立即执行函数 来达到 不暴露私有成员的目的

```javascript
const module2 = (function() {
  let _money = 100;
  const m1 = () => {
    console.log(123);
  };
  const m2 = () => {
    console.log(456);
  };
  return {
    f1: m1,
    f2: m2
  };
})();
```

> 以上就是模块化开发的基础中的基础。 没有库，没有规范，一切的维护都是靠人力，一切的创新，都是来源于 解放生产力。

## 二、模块化管理的发展历程

### 2-1、CommonJS

>

### 2-2、AMD 的 RequireJS

### 2-3、CMD 的 SaeJS

## 三、模块化框架原理

## 四、如何开项目开发中合理使用模块化
